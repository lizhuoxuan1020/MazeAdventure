2023年11月21日22:21:59
之前的simplify函数，随机选择一个点，判断是否为墙，且不为角落，然后凿开。一直重复直到凿开足够数量的墙。
假设迷宫中的网格为N*N,则迷宫为(2N+1)*(2N+1). 墙的数量和路块的数量各约2N^2个。
假设density=0.5,即挖一半的墙，那么要挖N^2个。
第一次取点，不考虑角落，那么取到墙的概率为0.5，最后一次取点，取到墙的概率为0.3左右。
那么取点次数的数学期望是多少呢？为了方便计算，假设概率为0.5不变，那么取点次数为2N^2。
好吧，发现复杂度不高。

所有精灵的坐标都采用的是迷宫内的坐标，即以迷宫的左上角为原点。而在显示的时候才转换。

2023年11月25日20:02:53
只实现最简单的版本：
    客户端点开后，点击开始游戏，即自动开始匹配对手。
    客户端退出后游戏自动终止。无法重新连接。
2023年11月26日10:34:44
为了让interface能更通用，游戏本身的draw应该在game中就实现。
为了让network更通用，不应该涉及interface.

2023年11月28日12:00:17
最好用到:
    协程（async, await, yield),
    线程(threading.Thread),
    同步(信号量，互斥锁),
    IO复用(select,epoll).

2023年11月28日15:39:43
在开始前，加上字幕。
玩家的互动：聊天框、表情包、语音等。
玩家的互动：即时排行榜，即时事件通告，
DIY: 玩家自己可以选择头像。

2023年11月29日14:42:58 搞清耦合关系
    服务器的网络，客户端的网络   （对所有游戏都普适，可以config）
    客户端的游戏菜单界面          （对所有游戏都普适，可以config）
    游戏逻辑、游戏刷新显式
    -----
后续应该加入登录和注册系统，因为玩家的ip可能会变，而游戏进度和记录应该和固定的用户信息相匹配。

2023年11月30日20:30:31
要分清什么时候游戏开始。是一连上加入吗，还是所有玩家准备好后进入。这里选择后者，并且固定玩家为两人。
后续可以改进。

2023年12月1日16:59:29
game中各元素定义好怎么绘制的方法。但具体的材料加载等在interface中统一实现。
每个元素中定义一个 self.materials={'images':[...], 'audios':[...], ...}
重写 __call__()的方法很精彩。建议记下。！！！！！【】【】【】【】【】


 '''
        事件主要用于客户端游戏界面的弹窗通知，增加互动感。
        弹窗可以是滚动的，或者飘过，或者直接并排依次显示。
        主要的动作有：
            get,put, 获取 丢弃
            buy,sell,
            try, 尝试
            raffle 抽奖
            kill,save,

        收集物里可以增加切斯特，或者小精灵跟班。
        收集元素来开启终极大门。
        梦之碎片，光之碎片，镜子（光），牡丹花（生命，光），金币。
        问号：惊喜盒子。 花金币 抽奖。
        '''
先不能更改键位。
因为窗口大小可以调整，所以游戏中的像素不应该和显示的像素等同，要有换算关系。

2023年12月1日23:45:42
现在有个问题：
    game_status实际上是对象map explorer等的复制，
    加载的图像和音频等都在里面，来回传输是不是太大了。
解决方法之一：
    game_status应该只包含一些关键信息，然后用game_status赋值本地的game对象，再调用game的draw.
解决方法之二：
    所有的draw()都在Game里进行，而map explorer等对象不负责draw.
先采用方法二吧，重写game_status太复杂了，赋值过程也很蛋疼。
    在Game以及内部的Map等类中只写明需要哪些多媒体材料，不加载。
    而在interface中统一提取materials关键字并加载。
    然后将加载好的材料作为参数传递给Game,让其绘制Game，而Interface绘制自己的界面。
    这样，既解耦合了，也避免了重复代码。

2023年12月2日03:28:48
一个屏幕上显示多大的视野，这应该有Game决定，而不是Interface，因为视野也是游戏难度的一部分。
同时，Game还应该确定长宽比。
用pygame计算的显示屏像素不准，自己测了一下，大约[1500, 1000]。那么长宽比就固定为1.5.
16:9  16:10  4:3  1:1  3:2
关于Game的显示范围与Interface中screen的关系.


2023年12月3日01:32:47
采用地图分块，并且每块包含该处的所有objects.
这样任何互动不需要进行遍历检查碰撞，而是先计算在哪个地图块，然后只检查这个地图块上的碰撞。

2023年12月3日13:07:47
地图块、人物块、物体块的计算尺寸和显示尺寸可以不同。
比如人物块的显示尺寸可以看情况稍微大一点，因为人物图像的周围有空白。

objects应该融入到map中，不应该另外写二维数组。

2023年12月3日14:46:13
提高鲁棒性：素材如果缺失，应该不影响游戏的运行！！而是用黑色surface或者空音乐代替。
    多用try, 或者用if判断再调用。

2023年12月3日15:20:44
把物体和功效分开。因为一个物体可以有多个功效，一个功效可能多个物体都拥有。

2023年12月3日17:19:37
用方向d代替速度v. 方向d每次只加一减一，再乘以vmax，不会出现错位的情况，总能归零。

下一步的位置不合法时，缩小一下dt再尝试，直到步足够小的时候再放弃。这样能在移速很快的时候贴到墙边。

2023年12月4日00:08:16 遇到了无限创建线程的BUG，找不出原因
下面这段代码会输出什么？总共会有多少个子线程被创建？
class CA:
    def print_a(self):
        print('a')
    def endless_loop(self):
        threading.Thread(target=self.print_a).start()
        while True:
            #一个无限循环，用于循环播放游戏画面。
            ...
            pygame.display.flip()
    def main(self):
        for i in range(10):
            self.endless_loop()
            print(i)
ca=CA()
ca.main()
GPT说会创建无限多的线程：
这段代码使用了threading模块来创建线程，并在endless_loop方法中启动了一个新线程。
在main方法中，循环调用了endless_loop方法。因此，每次调用endless_loop方法都会创建一个新的线程。
由于endless_loop方法包含一个无限循环，每次调用该方法都会启动一个新的线程，并在其中执行无限循环。
因此，线程的数量将不断增加，不会停止。
由于这是一个无限循环的代码片段，程序将永远无法执行到循环中的print(i)语句，所以将不会输出任何i的值。
总结：这段代码会创建大量的子线程，因为每次调用endless_loop方法都会启动一个新的线程，
而这些线程都包含一个无限循环。程序将不会停止创建线程，因此线程数量会一直增加。

下面的代码中，会打印几个'b'？
def print_a():
    print('a')
def func():
    threading.Thread(target=print_a).start()
    return
def main():
    for i in range(2):
        func()
        print('b')

2023年12月4日00:55:34 无限子线程问题解决了，原来只是打错了一个标志位字符串
导致其实没有进入无限循环部分。那么子程序就只是创建一个线程，也没有改变标志位。
于是在大循环中标志位没变，一直进入这个子程序，线程也被一直创建。
根本不是递归创建。也和局部、类方法无关。就是单纯马虎写错字。、
自己之前对于线程的理解是正确的。

2023年12月4日14:04:22
网络和界面是分开的。网络部分应该提供接口，来进行连接、就绪等等。
网络的接口应该足够详细，但足够完整。任何外界想调用时可以调用。
即时没有界面，应该也能用控制台进行调用，或者自己写test调用。

2023年12月4日15:43:24
自己创建消息队列和缓冲区，这是一种生产者消费者模型，能大大简化代码！！！
比如服务器中创建一个存放广播信息的列表，那么子线程就能一直去查看和广播，
而不需要每次在不同逻辑时手动去指定应该广播哪些内容。
线程一旦创建，就和主线程脱离了，这时候这种全局的消息队列非常重要！！！相当于线程间的通信。
线程池的思想也是如此，线程怎么实现执行不同函数的？就是通过一个全局队列！

消息队列因为既有加入又有取出，所以要注意怎么实现线程安全。

2023年12月4日18:26:16
地图上应该应该增加一些地形，比如格栅，人物走过去后会进入格栅下面，半透明的。
这样能大大增加趣味。
玩家可以伪装成西瓜等，对方过来吃的时候会被禁锢。
变形法杖，隐身机。
下雪天，下雨天。打雷，闪电会暂时照亮整个视野。

2023年12月4日18:43:54
路面的图块必须是能互相连接的。这就有两个方法：
    方法1：直接绘制一个很大的连贯图，然后切割。并在draw()中计算应该绘制哪几块。
        缺点：玩家可以通过地形记忆出自己在哪儿。
    方法2：用可密铺的图案。
又想到了一条优化方法：
    由于是Game负责绘制，而python中的参数都是XXX...
    算了，查了下，对于数组等都是引用传递。本来想着把素材库先一次性复制给Game。

2023年12月4日18:57:04
可以自己练习写一个渲染框架，用来画移动的影子、更符合光影效果的视野圆圈。
可以提前绘制渐变效果的滤镜。像素可以低一点，但渐变的段数要足够大。

2023年12月4日19:59:51
越来越发现，游戏的精髓是怎么优化速度。
核心就是哪些应该提前处理。哪些用空间来换取时间。
还有线程安全。

2023年12月5日00:29:28
服务器的广播线程应该在一开始就创建好，然后会一直广播，而不是游戏开始后才创建。

2023年12月5日01:02:23
优化想法+1  应该把下面两种思路合二为一：
思路一：提前把所有地图都预先绘制好，这样能减少即时绘制，而且提前绘制的地图可以很有连贯性。
    提前绘制可以想加什么就加什么，可以随机生成非常多的杂草、蘑菇等，甚至可以手绘。
    没有地块之间有分界线的问题。
    缺点：当地图很大而我们只显示一小部分地图时不划算。
思路二：按地图块即时绘制要显示的部分，更灵活。
    缺点：没法加太多元素，比如杂草、蘑菇等，每一次添加都是提高每一帧的运算量。
        地图块之间要么太重复要么有分隔感，不连贯。
        如果视角很广，就会包含非常多地图块，运算量也大！
但其实有种合二为一的方法！！！
就是仍然提前绘制地图，随机添加各种地图要素。然后切割成适当大小的地图块。动态加载。
杂草蘑菇等有静态的有动态的。组合即可。
等下个版本用这个思路优化。

2023年12月5日01:12:39
对于用状态值while循环的代码，每个子块都需要在最后面才更改状态值，因为这是进入下一个子块的条件。
子函数第一行修改状态值的意义完全没有。

2023年12月5日01:20:18
报文中包含状态值、信号等很重要！！因为服务器和客户端本质上只是互相远程收发数据，没法直接调用。
所以所有的状态控制都只在自身有用，而互相间状态的同步、数据的同步却需要固定频率重复发送和接收。
一方在就绪后另一方可能还未获知，那么接收的信息可能还是上一个状态下的信息。
需要不断确认！！！

2023年12月5日01:31:50
还是让广播线程直接读取game_status吧，而不是等主线程去刷新消息列表，自己再去读取。
因为这涉及到一个频率问题，而且每次都重复一次复制，完全没用。

2023年12月5日16:57:12
服务器向客户端的这条通路必须一开始就打开，服务器以固定频率广播，客户端即使接收并清空。
而客户端的发送则不能用广播的形式。因为客户端需要做到即使发送：一旦events不为空就要发送。
    这样才能让延时最小化。
    而且应该是阻塞式等待events，不是while空转等待！所以之前写的也是错的。
    需要用到threading中的condition或Event.
    确定了，就是event.wait()和event.clear().非常简单。前者休眠等待event.set()。

2023年12月6日11:30:53
socket对象也不能进行序列化，所以服务器需要自己发送给客户端id，又回到原来的逻辑了。
那么全局变量发送列表有没什么必要了，因为MATCHING和GAMING阶段都用不到。

2023年12月6日12:07:48
因为客户端中的recv线程是连接之前创建的，所以不能用
    while self.is_connected:
而是直接 while True.  但不连接直接收取会出错，所以：
    while True:
        if not self.is_connected:
            continue


p
2023年12月6日12:27:22
在觉得可能粘包的地方，加入sleep. 比如服务器连接好后sleep一小会儿再进行就绪，让客户端有时间获取id.

2023年12月6日18:48:18
统一用pos代替x,y
最好能用Numpy，后面可以直接用矩阵转换。

2023年12月6日19:26:25
光照的变化，用底色实现。天气系统。

新增：地图事件，脸朝着冲击波站立就能避开，或者背对着站立就能避开。
多用AI生成图片。

2023年12月7日00:37:35
吐了，pygame中的Event也不能序列化。所以自定义一个数据结构吧。这样也能剔除鼠标移动等这样的事件。
2023年12月7日01:23:51
亲测，对于一个pygame.Event对象，event.type, event.key都是整型。所以其实也不复杂。
只要提取这部分就行，没必要搞成字符串。
由于我想把network这部分做成普适的网络框架，只负责收发数据，适用于任何游戏框架。
所以，event的转换就在game或者interface中，选择interface.

-------------------------
2023年12月7日21:42:31
新增假墙，可以进入。
宝石有：全能彩色（能递补任何颜色），
要集齐所有四种颜色。一种颜色有了后就不能再拿了。

玩家互相有通报系统。互动有限：冰冻，致盲，眩晕，
毒蘑菇能让敌方中毒，画面眩晕滤镜+移动一定程度的不受控制。
模糊滤镜：让周围画面随机混乱。
中毒后颜色变得鲜艳。
咖啡能解掉任何负面效果。
新增：持续时间为t的效果。

2023年12月8日15:39:49
从逻辑上分析，客户端不能直接发键盘鼠标事件，而是只发送与游戏变更有关的东西。
比如鼠标随时都在移动，也可以随时都点，可以查看物品、查看状态、查看游戏中的NPC的对话，
这些其实都没有参与游戏变更，所以根本不需要发送。键盘也是，任何键位都可以按，也可以打字，但
只有那些涉及游戏玩家方向移动等按键才有用。
Events应该作为唯一的桥梁。只有events才能刷新游戏。

在之前的代码中：
    获取键盘鼠标事件的功能由Interface的渲染中添加实现，（因为pygame在这里init的）
    获取后转换成可序列化的对象刷新client的事件列表， client负责唤醒并发送。
    Game根据传来的events来改变自己。但Game没有主动发送过events. （因为Game只负责画那么一帧）
这其实是不对的。
    比如，Game负责渲染自己，那么鼠标移动到一些地方时会有本地互动，点击后会产生事件或动作。
    一些键盘也是。
    Interface根本不知道哪些键盘鼠标相应是有效的，所以它必须全部发送，导致发送频率变大。
改成：
    在Game的渲染中计算有效的actions. 这不会降低速度，因为之前interface中也是在渲染的那个循环里。
这个也有缺点：
    如果因为本地原因画面有延迟、滞后、丢帧等，那么就会错失action的产生。




2023年12月8日16:02:41：
多媒体资源分开存。游戏的存游戏，界面的存界面。

有时候不需要用多帧做动画，而是用一个连贯的图，让其移动或旋转。

2023年12月8日18:31:45
魔法效果应该是加在人物类里面。如果以后有其他类型效果再说。
暂时只考虑双人场景。鼠标左键给敌方使用，右键给自己使用。


--------------------------------------------- 新版本 v2
主要更改：
    就前面提到的这些。action由draw_and_act()一起产生。
    重写了action.
    游戏事件服务器只发送一次给客户端。客户端自己决定怎么绘制。
    更改：游戏事件在服务器就记录剩余时间，每次都发送。反正广播频率一直那么多。

暂时不要引入时间戳。如果后面要引入，则需要服务器统一分配时间，客户端不能调用本地时间。

2023年12月9日03:10:05
要分清哪些方法是客户端的，哪些是服务器的。

2023年12月9日05:01:38
终点应该是object，而不是地图本身的0-1值。因为终点可以很小，可以很多个。

2023年12月9日05:22:25
游戏结束的结算画面也应该在Game中实现，而不是Interface.

2023年12月9日18:29:46
音效播放的逻辑比较难。需要检测.play()后返回的Channel。
暂时给Game增加一个成员变量 channels. 每次有播放的时候加入，并检查是否播放完毕。
注意：对于只播放短时间的音乐，这个很简单，直接play(maxtime=毫秒数)即可。

2023年12月9日20:48:24
effects的想法
Object仍然不变，但其use后分两种：
    直接效果：对玩家进行永久改变
    effects:对玩家的效果列表中施加一个效果。
玩家的next_pos中，先计算effects。

buff的添加和移除，一种方法是直接更改原来的成员变量，移除时反向更改。一种是增加一层计算层。
选用第一种。第二种有点复杂。

为了操纵远程客户端，让其不能一直有效，可以加个加密或者验证，使用次数足够多了就失效。

把物品和效果合为一体。物品有存放、使用、还原方法。

2023年12月10日02:04:37
可以增加的新effect:
    获得一段时间的庇护，任何施加给自己的技能会施加给对方。
    隐身，并加速。
    感知宝石。可以感知一个自己还不拥有的宝石类型，并用脚印标出路径。
    感知终点。同上，但脚印会断断续续。
    站在墙边使用，将最近的那堵墙凿开。
    原地放置一个标记。
    隔着墙，跳到对面。并标记这堵墙。

    一次性铲子可以挖地下的一片土（相当于增加了一个方形的object)，可以挖出宝石。
    雷达显示距离远近，指南针显示方向。
    磁铁可以干扰指南针长达几十秒。

    增加画面闪烁，音乐渐进等，长时间待在某个标记位置，可以获得某些东西或技能。
新增可以撒在地上的巧克力豆。（双方都可见），可以多个叠加在包里。
金豆子标记的地方仅自己可见。
这个版本应该以迷宫为主，所以标记路很重要。

宝石的种类应该更多，更稀有。

结算界面应该给出自己的路径。或者自己走过的图上色，加上自己的标记。

2023年12月14日11:25:09
服务器与客户端之间的数据传送的代码非常薄弱，应该加入更多的exception处理机制。
现在鼠标一拖动客户端窗口，就会造成数据传送出错。
至少应该能让socket缓冲区爆满、空白，而不引起错误。
两边各自发送各自的，想发送多少发送多少，而接收想接收的格式，其他格式也不会引起错误。
根据查询socket缓冲区的接收区大小在8K~80K之间。
事实上，如果是阻塞模式，那么不存在爆满就出错的情况，而是会一直阻塞。


------------------------------------------------------------------------------ 大地图v3
2023年12月14日16:02:22 更新
客户端的发送：之前频率太高了，空操作也会高频发送。应该只发送有用信息。
容错：服务器的操作应该更有容错，多用try。比如客户端有时候因为不同步会发送给服务器错误的操作。
信息反馈：
    多用print，不要只在改BUG的时候才用。每个子线程都增加名字。给服务器等加入counter.
    增加ping值。
    数据收发的错误，必须能返回是什么数据。
游戏frame不需要取模，即时每秒100帧，那么到整数极限也是:
2**31/(24*60*60*100)=2,147,483,648/8,640,000=248天。
增加滤镜效果，而不是滤镜本身。这包括对surface上像素的数学操作。
利用frame模拟时间作为变量，即可实现动画。

----- 发送action部分
当前的act发送逻辑是：
interface提供的以FPS为频率的while循环：
    game在每一帧的绘制过程中都在刷新game.actions. 如果是空操作，就刷新成空列表。
    在同一帧下，interface将game.actions复制给client.events. client唤醒并立即发送。
这样，发送频率就和interface的帧率一致，即时空操作也在一直发送。client的唤醒机制根本没用到。
只需要在以下任何一个环节中加入一个比较即可，让空操作不发送数据给服务器。
    game的刷新是没有问题的，当下帧没有操作就应该刷新出空列表，这不耗时而且是必要的。
    interface在复制前应该加个判断，如果为空就不刷新。
    或者client可以接收空操作，但自己不会发送。
选择第一种。

----- 网络通信部分
recv()应该重写，之前太累赘了，而且完全没有理解socket缓冲区的机制!!!
当A给B持续发送数据时，B的数据接收出错的原因不在于B的接收区满了，
因为当接收区满了后A的send()也会被阻塞，不会出现错误。
问题在于B的接收区太慢而B每次recv()的数据不是一个整体！
https://blog.csdn.net/mijichui2153/article/details/81118171
要记住TCP是可靠的、不丢包的。所以关键在于怎么recv一个完整的包，不多也不少。
如果recv多了，就会把下一个包吃掉一部分，从而剩下的数据流不完整了。
方法一：让所有的数据都同样大小。方法二：带数据长度值的前缀。
这些在之前就已经实现了，关键在于recv函数的实现。让recv每次循环读取，直至读取一个完整的数据包。
recv不应该切开后面的包。


----- 容错部分
记住一点，客户端是没办法判断自己的操作和状态是否同步或合法的，只能盲发。
容错的任务在服务器。所以要改的是game的update方法，加入更多判断和try.即客户端发来的actions都是尝试。
把拾取也转换成动作。
不应该本地判断是否有效后才发送给服务器，而是让服务端自己判断。
亲测，快速操作方向键，会让移动出BUG，导致原地不动。
所以，重点是Game类中的两个update函数！
另外，由于Action中已经包括了玩家id,所以update函数的参数不需要id.
具体的，
    不要把按键放开看成是按键按下的反面从而统一处理，应该分开处理，放开后这个方向的朝向必须为0.
    给每一个物品都赋予一个独一无二的id，防止位置重叠且其他属性也一样，虽然可能性不大，但还是最好鲁棒些。
    方向键的松开如果送不到，那么确实会出现即使没按也一直移动的情况，根本没办法。
    单机版试了一下，怎么乱按都不会出现方向紊乱。所以这是网络包紊乱导致。
    只能隔一个小段时间把之前的按键的状态发送一次。
    想到惹！！！！ 客户端对比自己的键位和得到的广播中玩家的方向，如果不正确，就重新发送！！！
    这样本地的发送还是那么少。
    玩家的方向重写，就用四个数表示。
    O了，已解决。

    然后是变大变小会卡墙的BUG.
    变大或者恢复时，计算周围的x范围和y范围。重新计算最贴近的矩形，然后根据矩形计算新的形心pos.
    尺寸的变大变小和移动dt应该是互斥的，这点已经实现了。
    use()中新增参数map,用于计算卡墙，同时也能用于其他标记地图类或破坏地图类的物品！
    解决卡墙的方法是直接暴力去检验可能的几个适配方案。
    O了，已解决。（2023年12月15日05:35:41）

----- 新增特性
比如让一个半透明的大头像慢慢变大或者旋转，模仿很duang的感觉。
观战功能：可以看对方的视角。
所有的物品增加总寿命和每次使用后的寿命。对于一次性的就用1. 使用完后判断寿命是否完结。
猫咪和小狗，带身上有效果，或者使用后给脚印。
气球使用后可以像凯隐一样走墙。
蜡笔进行标记。
给每种物品一个提示语，鼠标放上面可以查看。不要太明显。有的可以不给提示。

地图标记和物品应该分开，否则要加入很多判断。标记与人物完全没有互动，且双方可能看到的不一样，所以单独建类。

可以设置一些标记点，用铲子或者站立不动，可以挖出宝石等。

可以让服务器将成功的actions再返回给客户端，让客户端去渲染动画和音效。
----- 精简资源
把一些用不到的音频都删了，图片的分辨率调小，让最后的包在100M以内。

----- ----------------------------------------------------------- v4 UDP
2023年12月16日21:53:36
server可以先不绑定游戏。server应该有独立运行的能力。而且服务器有换游戏的能力。
需要能应付有人退出或返回主菜单造成连接断开的能力。